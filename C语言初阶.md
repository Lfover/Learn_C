# C语言初阶

##  自己解决问题   

C是非常接近计算机体系结构，更讷讷感让我们感受计算机软硬件特性

2.C支持跨平台（不是编译器）的

3.C经典，底层开发

> 批量化注释：ctrl+k+c
>
> 批量化去注释：ctrl+k+u

## 0变量

1.如果代码运行时有warning 警告4996，可以在头文件那块加上**#pragma warning(disable:4996)**

2.局部变量和全局变量，同时存在时，局部变量的值覆盖全局变量的值

3.作用域与生命周期

> 1.有效的作用区域叫做作用域-->影响范围
>
> 2.一个变量被创建好到变量被销毁的一个时间段叫做这个变量的生命周期-->存在时间

## 1常量：

* 字面常量

  > 10；2.14；‘c'；“hello world”(只有值，没有名字)

* const修饰的常变量

  > （不能直接修改，但可以间接修改）

* #define定义的标识符常量

  > 1.为什么要有宏定义：见名知意，提升代码的可维护性

  > 2.宏定义可以定义在任何地方，但是它的有效作用域只有定义以后的区域，最好还是放到开头

* 枚举常量

  ```c++
  enum color{
  YELLOW,
  BLACK,
  RED,
  BLUE,
  };
  ```

  

## 2字符串

1.双引号引起的一串字符成为字符串面值，或建成字符串

> 字符串的结束标志是\0的转义字符，在计算字符串长度的时候\0是结束标志，不算作字符串的内容，但是计算空间的时候，例如sizeof(“ABC”)的值是4=3+1，加上\0的空间

2.转义字符

> \:转义
>
> \\":特殊字符转字面
>
> \n:字面含义转特殊--->\t是键盘tap键

3.strlen()

> strlen求的是字符串内容的长度，而sizeof求的是字符串所占大小

**C是没有字符串类型的，所以需要借助char*,或者char[]，来进行字符串的使用**

## 3数据类型

| 类型        | 字节数 |
| ----------- | ------ |
| int         | 4      |
| char        | 1      |
| short       | 2      |
| float       | 4      |
| double      | 8      |
| long        | 4      |
| long long   | 8      |
| long double | 8      |

### 4为什么提供这么多数据类型

> 本质是为了数据加工，计算机是为了解决人的计算问题的，而人的计算场景非常多

#  函数

定义函数的时候把首字母大写

函数调用好处

> 1.工程上，函数可以让我们的代码更具结构性，好看
>
> 2.维护性：提升代码的可维护性

1.返回值：该函数是否调用成功

2.函数名：见名知意

3.形参列表

4.函数体：代码块

#  数组

```c++
int main()
{
int arr[10];
int i=0;
for(;i<10;i++){
printf("arr[%d]:%d\n",i,arr[i]);
}
}
```

![image-20211010205155311](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20211010205155311.png)



##  操作符

### 移位运算符

```c++
int main ()
{
int x=15;//8+4+2+1=00000000 00000000 00000000 00001111
printf("%d\n",x>>1);//7=00000000 0000000 00000000 00000111
printf("%d\n",x<<1);//00000000 00000000 00000000 00011110
}//虽然x左移右移，但是不会影响x的值，除非赋值
```

> 将整数右移1位相当于÷2

# 关键字

####  0.typedef

typedef是类型定义，理解为类型重命名

**eg**

```c++
//将unsigned int 重命名为uint_32,所以uint_32也是一个类型名
typedef unsigned int uint_32;
int main()
{
//观察num1和num2，这两个变量的类型是一样的
unsigned int num1=0;
uint_32=0;
return 0;
}
```

####  1.static

* static可以用来修饰变量和函数
* 被static修饰后类似于全局变量，就不会重复定义i，她修改了局部变量的生命周期，让静态局部变量出了作用域仍然存在，到程序结束，生命周期才结束，但是它的作用域没有变化

**static修饰局部变量**

* ![image-20211011175323511](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20211011175323511.png)

**static修饰全局变量**

![image-20211011180657327](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20211011180657327.png)

**static修饰函数**

![image-20211011202656149](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20211011202656149.png)

####  2#define

* 宏只做简单的文本替换，单独出现的才会被直接替换
* 想做到理想状态，不要吝啬圆括号（）

![image-20211011210623997](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20211011210623997.png)

```c++
#define DOUBLE(x) x*x
//如果想要出现121，可以写成#define DOUBLE(X) (X)*(X)
//DOUBLE(10+1) 10+1*10+1===>21
#define DOUBLE(x) x+x
//10*DOUBLE(10+1)  10*10+1+10+1===>112
int main()
{
    printf("%d\n",DOUBLE(10+1));//21
    printf("%d\n",10*DOUBLE(10+1));
}
```

#  指针

####  0内存

![image-20211011213504611](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20211011213504611.png)

####  1为什么要有指针

* 对内存编址是为了提高查找效率，编址硬件电路自动完成的

* 什么是指针呢-？指针就是地址，在32位下是4字节，64位是8字节

* 指针变量是变量，变量里面放的内容是地址

* 计算机访问内存的基本单元是字节

* 以32位计算机为例，2^32 * 1字节=（2^10)*(2^10) *(2^10) *(2^2) *1字节=4GB

  ![image-20211011223018862](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20211011223018862.png)

> 用空间的：左值
>
> 用内容的：右值

![image-20211011223609112](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20211011223609112.png)

**对指针进行解引用，代表的是指针所指向的变量，但具体用的是变量的空间还是内容要取决于是左值还是右值**

*所有指针的大小32位是4字节，64位是8字节*



##  分支语句

##  循环语句

####  while

> 如果条件为0，则为假，1为真

![image-20211015215436119](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20211015215436119.png)

#####  getchar

> int c=getchar();读进去
>
> ##### ctrl+z表示对话框输入完毕，对话框里输入的都是字符

#####  putchar

> putchar()；打出来







# mem

## 1.malloc

* malloc申请内存，必须使用free释放
* malloc申请空间时，只是把内存空间给我，内存里面的东西没有变，可能是随机的，不做初始化
* 释放的时候会比较多是因为别人给你的内存总是比你要的要多
* 内存泄露本质上是内存浪费的现象，并没有少空间，短期不会有问题，但是为了完整，最好用free（）

## 2.calloc

* void* calloc (size_t num,size_t size);
* calloc定义后会初始化
* 一般实际申请空间的大小是需要稍微大于你所需要的内存空间大小的，多出来的空间不是给用户用的，是给系统进行管理的
* 我们把空间释放了，难道free不会自动对ptr 置为NULL嘛？不会！
* 一个指针指向一段没有使用权限的孔家，这样的指针我们叫做野指针（悬垂指针）
* 只有堆空间是需要free的
* 内存必须是整体申请整体释放的
* 堆空间不能重复释放

## 3.小知识点

> * 拷贝是真的进行数据拷贝，删除只要设置数据无效就行（所以拷贝要花几分钟，删除只要几秒钟）
> * 如果不小心删除了一个文件，只要不进行操作，那块内存没有被别的占用，就可以恢复
> * 申请空间以后，一定要进行合法性判定

![image-20211002202522553](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20211002202522553.png)